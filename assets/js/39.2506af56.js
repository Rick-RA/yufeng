(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{361:function(e,t,r){"use strict";r.r(t);var a=r(33),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"promise"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#promise"}},[e._v("#")]),e._v(" promise")]),e._v(" "),r("h2",{attrs:{id:"含义"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#含义"}},[e._v("#")]),e._v(" 含义")]),e._v(" "),r("h3",{attrs:{id:"对象的状态不受外界影响"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#对象的状态不受外界影响"}},[e._v("#")]),e._v(" 对象的状态不受外界影响")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("三种状态")]),e._v(" "),r("ul",[r("li",[e._v("Pending 进行中")]),e._v(" "),r("li",[e._v("Fulfilled已成功")]),e._v(" "),r("li",[e._v("Reject已失败")])])]),e._v(" "),r("li",[r("p",[e._v("只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。")])])]),e._v(" "),r("h3",{attrs:{id:"一旦状态改变就不会再变，任何时候都可以得到这个结果"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#一旦状态改变就不会再变，任何时候都可以得到这个结果"}},[e._v("#")]),e._v(" 一旦状态改变就不会再变，任何时候都可以得到这个结果")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("Promise状态的改变只有两种可能")]),e._v(" "),r("ul",[r("li",[e._v("1、从pending变为fulfilled")]),e._v(" "),r("li",[e._v("2、从pending变为Rejected")])])])]),e._v(" "),r("h3",{attrs:{id:"缺点："}},[r("a",{staticClass:"header-anchor",attrs:{href:"#缺点："}},[e._v("#")]),e._v(" 缺点：")]),e._v(" "),r("ul",[r("li",[e._v("无法取消Promise，一旦新建就会立即执行，无法中途取消。")]),e._v(" "),r("li",[e._v("如果不设置回调函数，Promise内部抛出的错误不会反应到外部。")]),e._v(" "),r("li",[e._v("当处于pending状态时，无法得知目前进展到那一阶段")])]),e._v(" "),r("h2",{attrs:{id:"基本用法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#基本用法"}},[e._v("#")]),e._v(" 基本用法")]),e._v(" "),r("h3",{attrs:{id:"promise对象本身是一个构造函数，用来生成promise实例"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#promise对象本身是一个构造函数，用来生成promise实例"}},[e._v("#")]),e._v(" Promise对象本身是一个构造函数，用来生成Promise实例")]),e._v(" "),r("h3",{attrs:{id:"then"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#then"}},[e._v("#")]),e._v(" then")]),e._v(" "),r("ul",[r("li",[e._v("第一个回调是Promise对象状态变为Resolved时调用")]),e._v(" "),r("li",[e._v("第二个回调是可选的，状态变为Reject时调用")])]),e._v(" "),r("h2",{attrs:{id:"promise-prototype-then"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#promise-prototype-then"}},[e._v("#")]),e._v(" Promise.prototype.then()")]),e._v(" "),r("h3",{attrs:{id:"then方法返回的是一个promise实例，因此可以采用链式写法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#then方法返回的是一个promise实例，因此可以采用链式写法"}},[e._v("#")]),e._v(" then方法返回的是一个Promise实例，因此可以采用链式写法")]),e._v(" "),r("h3",{attrs:{id:"then方法的第一个参数是resolved状态的回调函数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#then方法的第一个参数是resolved状态的回调函数"}},[e._v("#")]),e._v(" then方法的第一个参数是resolved状态的回调函数")]),e._v(" "),r("h3",{attrs:{id:"then方法的第二个参数（可选）是rejected状态的回调函数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#then方法的第二个参数（可选）是rejected状态的回调函数"}},[e._v("#")]),e._v(" then方法的第二个参数（可选）是rejected状态的回调函数")]),e._v(" "),r("h3",{attrs:{id:"前一个回调函数可能返回的是一个promise对象，而后一个回调函数就会等待该promise对象的状态发生变化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#前一个回调函数可能返回的是一个promise对象，而后一个回调函数就会等待该promise对象的状态发生变化"}},[e._v("#")]),e._v(" 前一个回调函数可能返回的是一个Promise对象，而后一个回调函数就会等待该Promise对象的状态发生变化")]),e._v(" "),r("h2",{attrs:{id:"promise-prototype-catch"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#promise-prototype-catch"}},[e._v("#")]),e._v(" Promise.prototype.catch()")]),e._v(" "),r("h3",{attrs:{id:"是-then-null-rejection-的别名，用于指定发生错误时的回调函数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#是-then-null-rejection-的别名，用于指定发生错误时的回调函数"}},[e._v("#")]),e._v(" 是.then(null,rejection)的别名，用于指定发生错误时的回调函数")]),e._v(" "),r("h3",{attrs:{id:"如果promise对象的状态变为resolved，则会执行then方法。如果状态变为rejected，则会执行catch方法。then方法中如果在运行中抛出错误，也会被catch方法捕获"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#如果promise对象的状态变为resolved，则会执行then方法。如果状态变为rejected，则会执行catch方法。then方法中如果在运行中抛出错误，也会被catch方法捕获"}},[e._v("#")]),e._v(" 如果Promise对象的状态变为Resolved，则会执行then方法。如果状态变为Rejected，则会执行catch方法。then方法中如果在运行中抛出错误，也会被catch方法捕获")]),e._v(" "),r("h3",{attrs:{id:"建议第二个参数使用catch的写法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#建议第二个参数使用catch的写法"}},[e._v("#")]),e._v(" 建议第二个参数使用catch的写法")]),e._v(" "),r("h2",{attrs:{id:"promise-all"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#promise-all"}},[e._v("#")]),e._v(" Promise.all()")]),e._v(" "),r("h3",{attrs:{id:"用于将多个promise包装成一个新的promise实例"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#用于将多个promise包装成一个新的promise实例"}},[e._v("#")]),e._v(" 用于将多个Promise包装成一个新的Promise实例")]),e._v(" "),r("h3",{attrs:{id:"var-p-promise-all-p1-p2-p3"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#var-p-promise-all-p1-p2-p3"}},[e._v("#")]),e._v(" var p = Promise.all([p1,p2,p3])")]),e._v(" "),r("h3",{attrs:{id:"只有p1-p2-p3的状态都有fulfilled，p的状态才会变成fulfilled"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#只有p1-p2-p3的状态都有fulfilled，p的状态才会变成fulfilled"}},[e._v("#")]),e._v(" 只有p1,p2,p3的状态都有fulfilled，p的状态才会变成fulfilled")]),e._v(" "),r("h3",{attrs:{id:"p1-p2-p3中有一个被rejected，p的状态就会变为rejected"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#p1-p2-p3中有一个被rejected，p的状态就会变为rejected"}},[e._v("#")]),e._v(" p1,p2,p3中有一个被Rejected，p的状态就会变为Rejected")]),e._v(" "),r("h2",{attrs:{id:"promise-race"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#promise-race"}},[e._v("#")]),e._v(" Promise.race()")]),e._v(" "),r("h3",{attrs:{id:"将多个promise实例包装成一个新的promise实例"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#将多个promise实例包装成一个新的promise实例"}},[e._v("#")]),e._v(" 将多个Promise实例包装成一个新的Promise实例")]),e._v(" "),r("h3",{attrs:{id:"var-p-promise-all-p1-p2-p3-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#var-p-promise-all-p1-p2-p3-2"}},[e._v("#")]),e._v(" var p = Promise.all([p1,p2,p3])")]),e._v(" "),r("h3",{attrs:{id:"p1-p2-p3中只要有一个实例率先改变状态，p的状态就会跟着改变。那个率先改变的promise实例的返回值就传递给p的回调函数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#p1-p2-p3中只要有一个实例率先改变状态，p的状态就会跟着改变。那个率先改变的promise实例的返回值就传递给p的回调函数"}},[e._v("#")]),e._v(" p1,p2,p3中只要有一个实例率先改变状态，p的状态就会跟着改变。那个率先改变的Promise实例的返回值就传递给p的回调函数")]),e._v(" "),r("h2",{attrs:{id:"promise-resolve"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#promise-resolve"}},[e._v("#")]),e._v(" Promise.resolve()")]),e._v(" "),r("h3",{attrs:{id:"参数是一个promise实例"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参数是一个promise实例"}},[e._v("#")]),e._v(" 参数是一个Promise实例")]),e._v(" "),r("ul",[r("li",[e._v("Promise.resolve将不做任何修改，原封不动的返回这个实例")])]),e._v(" "),r("h3",{attrs:{id:"参数是一个thenable对象"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参数是一个thenable对象"}},[e._v("#")]),e._v(" 参数是一个thenable对象")]),e._v(" "),r("ul",[r("li",[e._v("thenalbe对象指的是具有then方法的对象")]),e._v(" "),r("li",[e._v("Promise.resolve方法会将这个对象转为Promise对象，然后立即执行thenable对象的then方法")])]),e._v(" "),r("h3",{attrs:{id:"参数不是具有then方法的对象，或者根本不是对象"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参数不是具有then方法的对象，或者根本不是对象"}},[e._v("#")]),e._v(" 参数不是具有then方法的对象，或者根本不是对象")]),e._v(" "),r("ul",[r("li",[e._v("返回一个新的Promise对象，状态为Resolved")])]),e._v(" "),r("h3",{attrs:{id:"不带有任何参数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#不带有任何参数"}},[e._v("#")]),e._v(" 不带有任何参数")]),e._v(" "),r("ul",[r("li",[e._v("直接返回一个Resolved状态的Promise对象")])]),e._v(" "),r("h2",{attrs:{id:"promise-reject"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#promise-reject"}},[e._v("#")]),e._v(" Promise.reject()")]),e._v(" "),r("h3",{attrs:{id:"返回一个新的promise实例，状态为rejected"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#返回一个新的promise实例，状态为rejected"}},[e._v("#")]),e._v(" 返回一个新的Promise实例，状态为Rejected")]),e._v(" "),r("h2",{attrs:{id:"promise-try"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#promise-try"}},[e._v("#")]),e._v(" Promise.try()")])])}),[],!1,null,null,null);t.default=s.exports}}]);