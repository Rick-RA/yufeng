(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{356:function(t,a,s){"use strict";s.r(a);var r=s(33),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"class的基本用法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#class的基本用法"}},[t._v("#")]),t._v(" class的基本用法")]),t._v(" "),s("h2",{attrs:{id:"简介"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[t._v("#")]),t._v(" 简介")]),t._v(" "),s("h3",{attrs:{id:"_1、定义类的方法，不需要使用fuction关键字"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1、定义类的方法，不需要使用fuction关键字"}},[t._v("#")]),t._v(" 1、定义类的方法，不需要使用fuction关键字")]),t._v(" "),s("h3",{attrs:{id:"_2、方法之间不能有逗号，否则会报错"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2、方法之间不能有逗号，否则会报错"}},[t._v("#")]),t._v(" 2、方法之间不能有逗号，否则会报错")]),t._v(" "),s("h3",{attrs:{id:"_3、es6的类完全是构造函数的另外一种写法，如：point-point-prototype-constructor"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3、es6的类完全是构造函数的另外一种写法，如：point-point-prototype-constructor"}},[t._v("#")]),t._v(" 3、Es6的类完全是构造函数的另外一种写法，如：Point === Point.prototype.constructor")]),t._v(" "),s("h3",{attrs:{id:"_4、构造函数的prototype在es6的类上继续存在，类的所有方法都定义在类的prototype上"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4、构造函数的prototype在es6的类上继续存在，类的所有方法都定义在类的prototype上"}},[t._v("#")]),t._v(" 4、构造函数的prototype在ES6的类上继续存在，类的所有方法都定义在类的prototype上")]),t._v(" "),s("h3",{attrs:{id:"_5、object-assgin-可以方便的一次向类添加多个方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5、object-assgin-可以方便的一次向类添加多个方法"}},[t._v("#")]),t._v(" 5、Object.assgin()可以方便的一次向类添加多个方法")]),t._v(" "),s("h3",{attrs:{id:"_6、类内部定义的所有方法都是不可枚举的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6、类内部定义的所有方法都是不可枚举的"}},[t._v("#")]),t._v(" 6、类内部定义的所有方法都是不可枚举的")]),t._v(" "),s("h3",{attrs:{id:"_7、class的name属性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7、class的name属性"}},[t._v("#")]),t._v(" 7、class的name属性")]),t._v(" "),s("h2",{attrs:{id:"严格模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#严格模式"}},[t._v("#")]),t._v(" 严格模式")]),t._v(" "),s("h3",{attrs:{id:"es6把语言升级为了严格模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es6把语言升级为了严格模式"}},[t._v("#")]),t._v(" ES6把语言升级为了严格模式")]),t._v(" "),s("h2",{attrs:{id:"constructor"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#constructor"}},[t._v("#")]),t._v(" constructor()")]),t._v(" "),s("h3",{attrs:{id:"通过new命令生成对象时，会自动调用该方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#通过new命令生成对象时，会自动调用该方法"}},[t._v("#")]),t._v(" 通过new命令生成对象时，会自动调用该方法")]),t._v(" "),s("h3",{attrs:{id:"如果没有显示定义，一个空的constructor方法会默认添加"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如果没有显示定义，一个空的constructor方法会默认添加"}},[t._v("#")]),t._v(" 如果没有显示定义，一个空的constructor方法会默认添加")]),t._v(" "),s("h3",{attrs:{id:"默认返回实例对象-，this。也可以指定返回另外一个对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#默认返回实例对象-，this。也可以指定返回另外一个对象"}},[t._v("#")]),t._v(" 默认返回实例对象 ，this。也可以指定返回另外一个对象")]),t._v(" "),s("h3",{attrs:{id:"类必须通过new关键字来调用，否则会报错。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#类必须通过new关键字来调用，否则会报错。"}},[t._v("#")]),t._v(" 类必须通过new关键字来调用，否则会报错。")]),t._v(" "),s("h2",{attrs:{id:"类的实例对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#类的实例对象"}},[t._v("#")]),t._v(" 类的实例对象")]),t._v(" "),s("h3",{attrs:{id:"实例属性除非显示定义在其本身（this），否则都是定义在原型上"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实例属性除非显示定义在其本身（this），否则都是定义在原型上"}},[t._v("#")]),t._v(" 实例属性除非显示定义在其本身（this），否则都是定义在原型上")]),t._v(" "),s("h3",{attrs:{id:"类的所有实例共享一个原型对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#类的所有实例共享一个原型对象"}},[t._v("#")]),t._v(" 类的所有实例共享一个原型对象")]),t._v(" "),s("h3",{attrs:{id:"proto"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#proto"}},[t._v("#")]),t._v(" "),s("strong",[t._v("proto")])]),t._v(" "),s("h2",{attrs:{id:"class表达式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#class表达式"}},[t._v("#")]),t._v(" class表达式")]),t._v(" "),s("h3",{attrs:{id:"let-person-new-class"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#let-person-new-class"}},[t._v("#")]),t._v(" let person = new class {}()")]),t._v(" "),s("h2",{attrs:{id:"不存在变量提升"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#不存在变量提升"}},[t._v("#")]),t._v(" 不存在变量提升")]),t._v(" "),s("h2",{attrs:{id:"this指向"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#this指向"}},[t._v("#")]),t._v(" this指向")]),t._v(" "),s("h3",{attrs:{id:"bind"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#bind"}},[t._v("#")]),t._v(" bind()")]),t._v(" "),s("h3",{attrs:{id:"使用箭头函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用箭头函数"}},[t._v("#")]),t._v(" 使用箭头函数")]),t._v(" "),s("h2",{attrs:{id:"getter-setter"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#getter-setter"}},[t._v("#")]),t._v(" getter setter")]),t._v(" "),s("h3",{attrs:{id:"get"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#get"}},[t._v("#")]),t._v(" get")]),t._v(" "),s("h3",{attrs:{id:"set"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#set"}},[t._v("#")]),t._v(" set")]),t._v(" "),s("h2",{attrs:{id:"generator方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#generator方法"}},[t._v("#")]),t._v(" Generator方法")]),t._v(" "),s("h3",{attrs:{id:"如果一个方法前面有个-号，那么这个函数就是generator函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如果一个方法前面有个-号，那么这个函数就是generator函数"}},[t._v("#")]),t._v(" 如果一个方法前面有个*号，那么这个函数就是generator函数")]),t._v(" "),s("h2",{attrs:{id:"静态方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#静态方法"}},[t._v("#")]),t._v(" 静态方法")]),t._v(" "),s("h3",{attrs:{id:"类的方法前面加static关键字，表示该方法是一个静态方法。（静态方法只能被类调用，不能被类的实例调用，子类可以继承父类的静态方法，也可以在子类中通过super关键字直接调用）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#类的方法前面加static关键字，表示该方法是一个静态方法。（静态方法只能被类调用，不能被类的实例调用，子类可以继承父类的静态方法，也可以在子类中通过super关键字直接调用）"}},[t._v("#")]),t._v(" 类的方法前面加static关键字，表示该方法是一个静态方法。（静态方法只能被类调用，不能被类的实例调用，子类可以继承父类的静态方法，也可以在子类中通过super关键字直接调用）")]),t._v(" "),s("h2",{attrs:{id:"静态属性和实例属性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#静态属性和实例属性"}},[t._v("#")]),t._v(" 静态属性和实例属性")]),t._v(" "),s("h3",{attrs:{id:"静态属性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#静态属性"}},[t._v("#")]),t._v(" 静态属性")]),t._v(" "),s("ul",[s("li",[t._v("旧的写法，ES6规定，Class内部只有静态方法，没有静态属性。（静态属性的定义形式:Class.props = 1）")]),t._v(" "),s("li",[t._v("新的写法，直接在实例属性前面加个static关键字就可以了")])]),t._v(" "),s("h3",{attrs:{id:"实例属性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实例属性"}},[t._v("#")]),t._v(" 实例属性")]),t._v(" "),s("ul",[s("li",[t._v("实例属性可以直接写在class中")]),t._v(" "),s("li",[t._v("也可以写在构造函数constructor（）中")])]),t._v(" "),s("h2",{attrs:{id:"new-target"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#new-target"}},[t._v("#")]),t._v(" new.target")]),t._v(" "),s("h3",{attrs:{id:"在构造函数中，返回new命令所作用的构造函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#在构造函数中，返回new命令所作用的构造函数"}},[t._v("#")]),t._v(" 在构造函数中，返回new命令所作用的构造函数")])])}),[],!1,null,null,null);a.default=e.exports}}]);