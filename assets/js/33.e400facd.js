(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{352:function(r,t,a){"use strict";a.r(t);var e=a(33),o=Object(e.a)({},(function(){var r=this,t=r.$createElement,a=r._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[a("h1",{attrs:{id:"iterator和for-of"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#iterator和for-of"}},[r._v("#")]),r._v(" Iterator和for...of")]),r._v(" "),a("h2",{attrs:{id:"iterator概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#iterator概念"}},[r._v("#")]),r._v(" Iterator概念")]),r._v(" "),a("h3",{attrs:{id:"遍历器是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署了iterator接口，就可以完成遍历操作。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#遍历器是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署了iterator接口，就可以完成遍历操作。"}},[r._v("#")]),r._v(" 遍历器是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署了Iterator接口，就可以完成遍历操作。")]),r._v(" "),a("h3",{attrs:{id:"作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#作用"}},[r._v("#")]),r._v(" 作用")]),r._v(" "),a("ul",[a("li",[r._v("1、为各种数据结构提供一个统一的、简便的访问接口")]),r._v(" "),a("li",[r._v("2、使得数据结构的成员能够按照某种次序排列")]),r._v(" "),a("li",[r._v("3、ES6创造了一种新的遍历命令--for ...of循环，Iterator接口主要供for...of消费")])]),r._v(" "),a("h3",{attrs:{id:"遍历过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#遍历过程"}},[r._v("#")]),r._v(" 遍历过程")]),r._v(" "),a("ul",[a("li",[a("p",[r._v("1、创建一个指针对象，指向当前数据结构的起始位置。")])]),r._v(" "),a("li",[a("p",[r._v("2、第一次调用指针对象的next方法，可以将指针对象指向数据结构的第一个成员。")])]),r._v(" "),a("li",[a("p",[r._v("3、第二次调用指针对象的额next方法，指针就指向数据结构的第二个成员")])]),r._v(" "),a("li",[a("p",[r._v("4、不断调用对象的next方法，直到它指向数据结构的结束位置。")])]),r._v(" "),a("li",[a("p",[r._v("每次调用next方法会返回数据结构的当前成员信息。value和done")]),r._v(" "),a("ul",[a("li",[a("p",[r._v("value")]),r._v(" "),a("ul",[a("li",[r._v("当前成员的值")])])]),r._v(" "),a("li",[a("p",[r._v("done")]),r._v(" "),a("ul",[a("li",[r._v("一个布尔值，表示遍历是否结束")])])])])])]),r._v(" "),a("h2",{attrs:{id:"默认iterator接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#默认iterator接口"}},[r._v("#")]),r._v(" 默认Iterator接口")]),r._v(" "),a("h3",{attrs:{id:"为数据结构提供了一种统一的访问方式，即for-of"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为数据结构提供了一种统一的访问方式，即for-of"}},[r._v("#")]),r._v(" 为数据结构提供了一种统一的访问方式，即for...of")]),r._v(" "),a("h3",{attrs:{id:"默认的iterator接口部署在数据结构的symbol-iterator属性。或者说一个数据结构只要具有symbol-iterator属性，就可以认为它是-可遍历的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#默认的iterator接口部署在数据结构的symbol-iterator属性。或者说一个数据结构只要具有symbol-iterator属性，就可以认为它是-可遍历的"}},[r._v("#")]),r._v(" 默认的Iterator接口部署在数据结构的Symbol.iterator属性。或者说一个数据结构只要具有Symbol.Iterator属性，就可以认为它是“可遍历的”")]),r._v(" "),a("h3",{attrs:{id:"原生具备iterator结构的数据结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原生具备iterator结构的数据结构"}},[r._v("#")]),r._v(" 原生具备Iterator结构的数据结构")]),r._v(" "),a("ul",[a("li",[r._v("Array")]),r._v(" "),a("li",[r._v("Map")]),r._v(" "),a("li",[r._v("Set")]),r._v(" "),a("li",[r._v("String")]),r._v(" "),a("li",[r._v("TypedArray")]),r._v(" "),a("li",[r._v("函数的arguments对象")]),r._v(" "),a("li",[r._v("NodeList对象")])]),r._v(" "),a("h3",{attrs:{id:"object对象类型默认不具有iterator结构，故不能使用for-of遍历它。除非实现了symbol-iterator属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#object对象类型默认不具有iterator结构，故不能使用for-of遍历它。除非实现了symbol-iterator属性"}},[r._v("#")]),r._v(" Object对象类型默认不具有Iterator结构，故不能使用for...of遍历它。除非实现了Symbol.Iterator属性")]),r._v(" "),a("h2",{attrs:{id:"遍历器对象的return-throw"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#遍历器对象的return-throw"}},[r._v("#")]),r._v(" 遍历器对象的return(),throw()")]),r._v(" "),a("h3",{attrs:{id:"next方法是必须的，return和throw是可选的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#next方法是必须的，return和throw是可选的"}},[r._v("#")]),r._v(" next方法是必须的，return和throw是可选的")]),r._v(" "),a("h3",{attrs:{id:"return"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#return"}},[r._v("#")]),r._v(" return()")]),r._v(" "),a("ul",[a("li",[r._v("如果for...of循环提前退出（通常是出错，或者有break语句或continue语句），就会调用return方法；")]),r._v(" "),a("li",[r._v("如果一个对象在完成遍历前需要清理或释放资源，就可以部署return方法。")])]),r._v(" "),a("h2",{attrs:{id:"javascript原有的for-in循环只能获得对象的键名，不能直接获取键值。for-of可以"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#javascript原有的for-in循环只能获得对象的键名，不能直接获取键值。for-of可以"}},[r._v("#")]),r._v(" javascript原有的for...in循环只能获得对象的键名，不能直接获取键值。for...of可以")]),r._v(" "),a("h2",{attrs:{id:"与其他遍历语法的比较"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#与其他遍历语法的比较"}},[r._v("#")]),r._v(" 与其他遍历语法的比较")]),r._v(" "),a("h3",{attrs:{id:"for"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#for"}},[r._v("#")]),r._v(" for")]),r._v(" "),a("ul",[a("li",[a("p",[r._v("这种写法比较麻烦，因此数组提供了内置的forEach方法")])]),r._v(" "),a("li",[a("p",[r._v("forEach的缺点：")]),r._v(" "),a("ul",[a("li",[r._v("无法中途跳出forEach循环，break命令或return命令都不能奏效。")])])])]),r._v(" "),a("h3",{attrs:{id:"for-in"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#for-in"}},[r._v("#")]),r._v(" for...in")]),r._v(" "),a("ul",[a("li",[r._v("可以遍历数组的键名")]),r._v(" "),a("li",[r._v('数组键名是数字，但是for...in循环是以字符串作为键名 "0","1"')]),r._v(" "),a("li",[r._v("不仅可以遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键")]),r._v(" "),a("li",[r._v("某些情况下，for...in循环会以任意顺序遍历键名")]),r._v(" "),a("li",[r._v("总之，for...in主要为遍历对象而设计，不适合遍历数组")])]),r._v(" "),a("h3",{attrs:{id:"for-of"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#for-of"}},[r._v("#")]),r._v(" for...of")]),r._v(" "),a("ul",[a("li",[r._v("有着和for...in一样简洁的写法，但是没有for...in的那些缺点")]),r._v(" "),a("li",[r._v("不同于forEach方法，可以与break，continue，和return配合使用")]),r._v(" "),a("li",[r._v("提供了遍历所有数据结构的统一操作接口。")])]),r._v(" "),a("h2",{attrs:{id:"调用iterator接口的场合"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#调用iterator接口的场合"}},[r._v("#")]),r._v(" 调用Iterator接口的场合")]),r._v(" "),a("h3",{attrs:{id:"解构赋值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解构赋值"}},[r._v("#")]),r._v(" 解构赋值")]),r._v(" "),a("h3",{attrs:{id:"扩展运算符"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#扩展运算符"}},[r._v("#")]),r._v(" 扩展运算符")]),r._v(" "),a("h3",{attrs:{id:"yield"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#yield"}},[r._v("#")]),r._v(" yield*")]),r._v(" "),a("h3",{attrs:{id:"其他"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#其他"}},[r._v("#")]),r._v(" 其他")])])}),[],!1,null,null,null);t.default=o.exports}}]);