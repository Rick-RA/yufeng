(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{351:function(t,s,a){"use strict";a.r(s);var r=a(33),e=Object(r.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"class的继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#class的继承"}},[t._v("#")]),t._v(" Class的继承")]),t._v(" "),a("h2",{attrs:{id:"简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[t._v("#")]),t._v(" 简介")]),t._v(" "),a("h3",{attrs:{id:"_1、通过extends关键字实现继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、通过extends关键字实现继承"}},[t._v("#")]),t._v(" 1、通过extends关键字实现继承")]),t._v(" "),a("h3",{attrs:{id:"_2、子类必须在construtor方法中调用super方法，否则新建实例会报错。（子类没有自己的this对象，需要继承父类的this对象进行加工）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、子类必须在construtor方法中调用super方法，否则新建实例会报错。（子类没有自己的this对象，需要继承父类的this对象进行加工）"}},[t._v("#")]),t._v(" 2、子类必须在construtor方法中调用super方法，否则新建实例会报错。（子类没有自己的this对象，需要继承父类的this对象进行加工）")]),t._v(" "),a("h3",{attrs:{id:"_3、继承的实质"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、继承的实质"}},[t._v("#")]),t._v(" 3、继承的实质")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("ES5")]),t._v(" "),a("ul",[a("li",[t._v("1、先创建子类的实例this")]),t._v(" "),a("li",[t._v("2、将父类的方法添加到this上")])])]),t._v(" "),a("li",[a("p",[t._v("ES6")]),t._v(" "),a("ul",[a("li",[t._v("1、先创建父类的实例this（所以构造函数中必须先调用super方法）")]),t._v(" "),a("li",[t._v("2、然后用子类的构造函数修改this")])])])]),t._v(" "),a("h3",{attrs:{id:"_4、子类构造函数中，只有调用super之后才可以使用this关键字，否则会报错。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4、子类构造函数中，只有调用super之后才可以使用this关键字，否则会报错。"}},[t._v("#")]),t._v(" 4、子类构造函数中，只有调用super之后才可以使用this关键字，否则会报错。")]),t._v(" "),a("h2",{attrs:{id:"object-getprototypeof"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#object-getprototypeof"}},[t._v("#")]),t._v(" Object.getPrototypeOf()")]),t._v(" "),a("h3",{attrs:{id:"判断一个类是否继承了另一个类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#判断一个类是否继承了另一个类"}},[t._v("#")]),t._v(" 判断一个类是否继承了另一个类")]),t._v(" "),a("h2",{attrs:{id:"super"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#super"}},[t._v("#")]),t._v(" super")]),t._v(" "),a("h3",{attrs:{id:"_1、作为函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、作为函数"}},[t._v("#")]),t._v(" 1、作为函数")]),t._v(" "),a("ul",[a("li",[t._v("作为函数时，只能在子类的构造函数中调用，其他地方会报错。相当于A.prototype.constructor.call(this)")])]),t._v(" "),a("h3",{attrs:{id:"_2、作为对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、作为对象"}},[t._v("#")]),t._v(" 2、作为对象")]),t._v(" "),a("ul",[a("li",[t._v("普通方法中指向父类的原型对象（无法访问定义在父类实例方法，而不是原型方法中的属性和方法）")]),t._v(" "),a("li",[t._v("静态方法中指向父类")])]),t._v(" "),a("h2",{attrs:{id:"类的prototype和-proto"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类的prototype和-proto"}},[t._v("#")]),t._v(" 类的prototype和__proto__")]),t._v(" "),a("h3",{attrs:{id:"简介-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#简介-2"}},[t._v("#")]),t._v(" 简介")]),t._v(" "),a("ul",[a("li",[t._v("作为一个对象，子类的原型__proto__是父类")]),t._v(" "),a("li",[t._v("作为构造函数，子类的prototype是父类的实例")])]),t._v(" "),a("h3",{attrs:{id:"extends的继承目标"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#extends的继承目标"}},[t._v("#")]),t._v(" extends的继承目标")]),t._v(" "),a("h3",{attrs:{id:"proto-属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#proto-属性"}},[t._v("#")]),t._v(" __proto__属性")]),t._v(" "),a("h2",{attrs:{id:"原生构造函数的继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原生构造函数的继承"}},[t._v("#")]),t._v(" 原生构造函数的继承")]),t._v(" "),a("h3",{attrs:{id:"es5子类无法获得原生构造函数内部的属性，故原生构造函数无法继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#es5子类无法获得原生构造函数内部的属性，故原生构造函数无法继承"}},[t._v("#")]),t._v(" ES5子类无法获得原生构造函数内部的属性，故原生构造函数无法继承")]),t._v(" "),a("h3",{attrs:{id:"es6允许继承原生构造函数定义子类，因为es6先新建父类的实例this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#es6允许继承原生构造函数定义子类，因为es6先新建父类的实例this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承"}},[t._v("#")]),t._v(" ES6允许继承原生构造函数定义子类，因为ES6先新建父类的实例this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承")]),t._v(" "),a("h2",{attrs:{id:"mixin模式的实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mixin模式的实现"}},[t._v("#")]),t._v(" Mixin模式的实现")]),t._v(" "),a("h3",{attrs:{id:"将多个类的接口混入另一个类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#将多个类的接口混入另一个类"}},[t._v("#")]),t._v(" 将多个类的接口混入另一个类")])])}),[],!1,null,null,null);s.default=e.exports}}]);